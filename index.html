<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BOBOTOG' PDF MAKER</title>
  <style>
    :root{
      --bg:#f7f7f9;
      --card:#ffffff;
      --accent:#0f172a;
      --muted:#6b7280;
      --radius:10px;
      --gap:12px;
      --shadow: 0 6px 20px rgba(2,6,23,0.04);
      --max-width:1100px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,"Noto Sans",sans-serif;
      background:var(--bg);
      color:#0b1220;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      justify-content:center;
      padding:20px;
    }

    .wrap{width:100%;max-width:var(--max-width)}
    header{display:flex;align-items:center;justify-content:space-between;gap:var(--gap);margin-bottom:14px}
    header .title{display:flex;align-items:center;gap:14px}
    header h1{margin:0;font-size:18px;font-weight:700}
    header p{margin:0;color:var(--muted);font-size:13px}

    .card{background:var(--card);border-radius:var(--radius);padding:14px;box-shadow:var(--shadow);}

    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}

    input[type="file"]{padding:8px;border-radius:8px;border:1px solid #e6e7eb;cursor:pointer}
    input[type="text"], select{padding:10px;border-radius:8px;border:1px solid #e6e7eb;min-width:150px}

    .btn{background:var(--accent);color:white;border:0;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600;transition:all 0.2s}
    .btn:hover{opacity:0.9;transform:translateY(-1px)}
    .btn:disabled{opacity:0.5;cursor:not-allowed}
    .btn.ghost{background:transparent;color:var(--accent);border:1px solid #e6e7eb}
    .btn.secondary{background:#374151}
    .btn.danger{background:#ef4444}

    .file-list{margin-top:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px}
    .file-item{display:flex;gap:12px;align-items:center;padding:10px;border-radius:10px;border:1px solid #eef2f7;background:#fff}
    .thumb{width:120px;height:80px;object-fit:cover;border-radius:6px;background:#f8fafc}
    .file-meta{flex:1;display:flex;flex-direction:column;gap:6px}
    .file-row{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .file-name{font-weight:700;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .small{font-size:13px;color:var(--muted)}

    .modal-backdrop{position:fixed;inset:0;background:rgba(2,6,23,0.45);display:none;align-items:center;justify-content:center;padding:20px;z-index:50}
    .editor{width:100%;max-width:1100px;background:var(--card);border-radius:12px;padding:12px;max-height:90vh;overflow:auto}
    .editor-top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px}
    .editor-canvas-wrap{background:#111827;padding:8px;display:flex;justify-content:center;align-items:center;border-radius:8px}
    canvas.editor-canvas{background:#fff;max-width:100%;height:auto;display:block;border-radius:4px}

    .editor-grid{display:grid;grid-template-columns:1fr 320px;gap:12px}

    .bottom-bar{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:12px}
    .logo-slot{display:flex;align-items:center;gap:10px}
    .logo-slot img{width:40px;height:40px;object-fit:contain}

    @media (max-width:900px){
      header{flex-direction:column;align-items:flex-start}
      .controls{width:100%;justify-content:space-between}
      .editor-grid{grid-template-columns:1fr}
      .file-list{grid-template-columns:1fr}
      .thumb{width:96px;height:64px}
    }

    @media (max-width:520px){
      body{padding:12px}
      .btn{padding:10px 12px;font-size:14px}
      .controls{flex-direction:column;align-items:stretch}
      input[type="file"], input[type="text"], select{width:100%}
      .file-item{flex-direction:row}
      .editor{padding:10px}
      header h1{font-size:16px}
      header p{font-size:12px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1 id="siteTitle">BOBOTOG' PDF MAKER</h1>
        <p id="siteDesc">Yuklang, tahrirlang va PDF yuklab oling. Har bir rasm o'z nisbatini saqlaydi.</p>
      </div>
      <div class="small">v2.0 — Professional</div>
    </header>

    <div class="card">
      <div class="controls" style="justify-content:space-between">
        <div class="col" style="flex:1;min-width:220px">
          <label class="small" id="labelChoose">Rasm tanlang (bir nechta)</label>
          <input id="fileInput" type="file" accept="image/*" multiple>
        </div>

        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <div class="col">
            <label class="small" id="labelPdfName">PDF nomi</label>
            <input id="filename" type="text" value="documents" style="min-width:180px">
          </div>

          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button id="mergeBtn" class="btn ghost">Birlashtirish</button>
            <button id="downloadBtn" class="btn">PDF yuklab olish</button>
          </div>

          <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
            <select id="langSelect">
              <option value="uz">O'zbek</option>
              <option value="ru">Русский</option>
            </select>
            <div class="small" id="langNote">Til</div>
          </div>
        </div>
      </div>

      <div id="fileList" class="file-list"></div>

      <div style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap">
        <div class="small" id="supportNote">Qo'llab-quvvatlanadi: kesish, burish, aks ettirish, oq-qora. Jonli ko'rinish.</div>
        <div class="small" id="tipPdf">PDF sahifalar rasmlar bilan bir xil nisbatda bo'ladi.</div>
      </div>
    </div>

    <div class="bottom-bar">
      <div class="logo-slot">
        <img id="siteIcon" src="icon.png" alt="BOBOTOG'" onerror="this.style.opacity=0.4; this.style.filter='grayscale(80%)';">
        <div>
          <div class="small" id="slogan">Sadriddinov Islom tomonidan yaratilgan ©</div>
        </div>
      </div>
      <div class="small">Barqaror • Oddiy • Moslashuvchan</div>
    </div>

  </div>

  <div id="editorModal" class="modal-backdrop">
    <div class="editor card">
      <div class="editor-top">
        <div style="display:flex;align-items:center;gap:12px">
          <strong id="editorTitle">Tahrirlash</strong>
          <div class="small" id="editorInfo"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="resetBtn" class="btn ghost">Qayta tiklash</button>
          <button id="applyBtn" class="btn">Saqlash</button>
          <button id="closeEditor" class="btn secondary">Yopish</button>
        </div>
      </div>

      <div class="editor-grid">
        <div>
          <div class="editor-canvas-wrap">
            <canvas id="editorCanvas" class="editor-canvas"></canvas>
          </div>
          <div class="small" style="margin-top:8px" id="helpCrop">Kesish uchun sichqoncha bilan hudud belgilang va "Kesishni qo'llash" tugmasini bosing.</div>
        </div>

        <div>
          <div style="display:flex;flex-direction:column;gap:8px">
            <div>
              <label class="small">Kontrast: <span id="edContrastVal">1.20</span></label>
              <input id="edContrast" type="range" min="0.4" max="3" step="0.05" value="1.2" style="width:100%">
            </div>

            <div>
              <label class="small"><input id="edBW" type="checkbox"> Oq-qora rejim</label>
            </div>

            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="rotLeft" class="btn ghost">⟲ 90°</button>
              <button id="rotRight" class="btn ghost">⟳ 90°</button>
              <button id="flipH" class="btn ghost">↔ Gorizontal</button>
              <button id="flipV" class="btn ghost">↕ Vertikal</button>
              <button id="applyCrop" class="btn ghost">Kesishni qo'llash</button>
            </div>

            <div style="display:flex;gap:6px">
              <button id="toPrev" class="btn ghost">← Oldingi</button>
              <button id="toNext" class="btn ghost">Keyingi →</button>
            </div>

            <div style="margin-top:8px">
              <div class="small">Asl o'lcham: <span id="origSize">—</span></div>
              <div class="small">Hozirgi o'zgarishlar: <span id="curTransform">—</span></div>
            </div>

            <div style="margin-top:10px;display:flex;gap:8px">
              <button id="applyAndClose" class="btn" style="width:100%">Saqlash va yopish</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
  (function(){
    const fileInput = document.getElementById('fileInput');
    const fileListEl = document.getElementById('fileList');
    const filenameInput = document.getElementById('filename');
    const downloadBtn = document.getElementById('downloadBtn');
    const mergeBtn = document.getElementById('mergeBtn');
    const langSelect = document.getElementById('langSelect');

    const editorModal = document.getElementById('editorModal');
    const editorCanvas = document.getElementById('editorCanvas');
    const edContrast = document.getElementById('edContrast');
    const edContrastVal = document.getElementById('edContrastVal');
    const edBW = document.getElementById('edBW');
    const rotLeft = document.getElementById('rotLeft');
    const rotRight = document.getElementById('rotRight');
    const flipHBtn = document.getElementById('flipH');
    const flipVBtn = document.getElementById('flipV');
    const applyCropBtn = document.getElementById('applyCrop');
    const resetBtn = document.getElementById('resetBtn');
    const closeEditorBtn = document.getElementById('closeEditor');
    const applyBtn = document.getElementById('applyBtn');
    const applyAndClose = document.getElementById('applyAndClose');
    const editorTitle = document.getElementById('editorTitle');
    const editorInfo = document.getElementById('editorInfo');
    const origSizeEl = document.getElementById('origSize');
    const curTransformEl = document.getElementById('curTransform');
    const toPrev = document.getElementById('toPrev');
    const toNext = document.getElementById('toNext');
    const helpCrop = document.getElementById('helpCrop');

    const langNote = document.getElementById('langNote');
    const siteTitle = document.getElementById('siteTitle');
    const siteDesc = document.getElementById('siteDesc');
    const labelChoose = document.getElementById('labelChoose');
    const labelPdfName = document.getElementById('labelPdfName');
    const supportNote = document.getElementById('supportNote');
    const tipPdf = document.getElementById('tipPdf');
    const slogan = document.getElementById('slogan');

    let files = [];
    let editingIndex = -1;

    function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,7); }

    const TRANSLATIONS = {
      ru: {
        siteTitle: 'BOBOTOG\' PDF MAKER',
        siteDesc: 'Загружайте фото, редактируйте и скачивайте PDF. Каждое изображение сохраняет свои пропорции.',
        choose: 'Выберите изображения',
        pdfName: 'Название PDF',
        download: 'Скачать PDF',
        merge: 'Объединить',
        lang: 'Язык',
        support: 'Доступно: обрезка, поворот, отражение, чёрно-белое. Предпросмотр в реальном времени.',
        tipPdf: 'Страницы PDF будут иметь те же пропорции, что и финальные изображения.',
        slogan: 'Создано Sadriddinov Islom ©',
        footer: 'Стабильно • Просто • Адаптивно',
        editBtn: 'Редактировать',
        deleteBtn: 'Удалить',
        editorTitle: 'Редактирование',
        reset: 'Сбросить',
        save: 'Сохранить',
        close: 'Закрыть',
        saveClose: 'Сохранить и закрыть',
        contrast: 'Контраст',
        bw: 'Чёрно-белое',
        rotLeft: '⟲ 90°',
        rotRight: '⟳ 90°',
        flipH: '↔ Горизонталь',
        flipV: '↕ Вертикаль',
        applyCrop: 'Применить обрезку',
        prev: '← Предыдущее',
        next: 'Следующее →',
        origSize: 'Исходный размер',
        curTransform: 'Текущие изменения',
        helpCrop: 'Выделите область мышью и нажмите "Применить обрезку".',
        generating: 'Создание PDF...',
        merging: 'Объединение...',
        noFiles: 'Нет файлов',
        selectTwo: 'Выберите ровно 2 изображения для объединения',
        merged: 'Изображения объединены и добавлены в список.',
        selectArea: 'Сначала выделите область для обрезки.',
        cropSet: 'Обрезка установлена. Нажмите "Сохранить", чтобы применить.'
      },
      uz: {
        siteTitle: 'BOBOTOG\' PDF MAKER',
        siteDesc: 'Yuklang, tahrirlang va PDF yuklab oling. Har bir rasm o\'z nisbatini saqlaydi.',
        choose: 'Rasm tanlang (bir nechta)',
        pdfName: 'PDF nomi',
        download: 'PDF yuklab olish',
        merge: 'Birlashtirish',
        lang: 'Til',
        support: 'Qo\'llab-quvvatlanadi: kesish, burish, aks ettirish, oq-qora. Jonli ko\'rinish.',
        tipPdf: 'PDF sahifalar rasmlar bilan bir xil nisbatda bo\'ladi.',
        slogan: 'Sadriddinov Islom tomonidan yaratilgan ©',
        footer: 'Barqaror • Oddiy • Moslashuvchan',
        editBtn: 'Tahrirlash',
        deleteBtn: 'O\'chirish',
        editorTitle: 'Tahrirlash',
        reset: 'Qayta tiklash',
        save: 'Saqlash',
        close: 'Yopish',
        saveClose: 'Saqlash va yopish',
        contrast: 'Kontrast',
        bw: 'Oq-qora rejim',
        rotLeft: '⟲ 90°',
        rotRight: '⟲ 90°',
        flipH: '↔ Gorizontal',
        flipV: '↕ Vertikal',
        applyCrop: 'Kesishni qo\'llash',
        prev: '← Oldingi',
        next: 'Keyingi →',
        origSize: 'Asl o\'lcham',
        curTransform: 'Hozirgi o\'zgarishlar',
        helpCrop: 'Kesish uchun sichqoncha bilan hudud belgilang va "Kesishni qo\'llash" tugmasini bosing.',
        generating: 'PDF yaratilmoqda...',
        merging: 'Birlashtirilmoqda...',
        noFiles: 'Fayllar yo\'q',
        selectTwo: 'Birlashtirish uchun aynan 2 ta rasm tanlang',
        merged: 'Rasmlar birlashtirildi va ro\'yxatga qo\'shildi.',
        selectArea: 'Avval kesish uchun hudud belgilang.',
        cropSet: 'Kesish o\'rnatildi. Qo\'llash uchun "Saqlash" tugmasini bosing.'
      }
    };

    function setLang(lang){
      const t = TRANSLATIONS[lang] || TRANSLATIONS.uz;
      siteTitle.textContent = t.siteTitle;
      siteDesc.textContent = t.siteDesc;
      labelChoose.textContent = t.choose;
      labelPdfName.textContent = t.pdfName;
      downloadBtn.textContent = t.download;
      mergeBtn.textContent = t.merge;
      langNote.textContent = t.lang;
      supportNote.textContent = t.support;
      tipPdf.textContent = t.tipPdf;
      slogan.textContent = t.slogan;
      resetBtn.textContent = t.reset;
      applyBtn.textContent = t.save;
      closeEditorBtn.textContent = t.close;
      applyAndClose.textContent = t.saveClose;
      rotLeft.textContent = t.rotLeft;
      rotRight.textContent = t.rotRight;
      flipHBtn.textContent = t.flipH;
      flipVBtn.textContent = t.flipV;
      applyCropBtn.textContent = t.applyCrop;
      toPrev.textContent = t.prev;
      toNext.textContent = t.next;
      edBW.nextSibling.textContent = ' ' + t.bw;
      helpCrop.textContent = t.helpCrop;
      
      try { localStorage.setItem('bobotog_lang', lang); } catch(e){}
    }

    const savedLang = (function(){ try{return localStorage.getItem('bobotog_lang')||'uz'}catch(e){return 'uz'} })();
    langSelect.value = savedLang;
    setLang(savedLang);
    langSelect.addEventListener('change', ()=> setLang(langSelect.value));

    fileInput.addEventListener('change', async (e) => {
      const inputFiles = Array.from(e.target.files || []);
      for (const f of inputFiles){
        const id = uid();
        const previewUrl = URL.createObjectURL(f);
        const originalDataUrl = await readFileAsDataURL(f);
        const dims = await getImageSize(originalDataUrl);
        files.push({
          id, name: f.name, file: f,
          previewUrl, originalDataUrl,
          naturalWidth: dims.width, naturalHeight: dims.height,
          settings: { rotation: 0, flipH:false, flipV:false, contrast:1.2, bw:false, crop: null },
          editedDataUrl: null,
          selected: false
        });
      }
      renderList();
      fileInput.value = '';
    });

    function readFileAsDataURL(file){
      return new Promise((res, rej)=>{
        const fr = new FileReader();
        fr.onload = () => res(fr.result);
        fr.onerror = rej;
        fr.readAsDataURL(file);
      });
    }

    function getImageSize(dataUrl){
      return new Promise(res=>{
        const img = new Image();
        img.onload = () => res({width: img.naturalWidth, height: img.naturalHeight});
        img.src = dataUrl;
      });
    }

    function renderList(){
      const t = TRANSLATIONS[langSelect.value];
      fileListEl.innerHTML = '';
      files.forEach((f, idx) => {
        const div = document.createElement('div');
        div.className = 'file-item';
        const left = document.createElement('div');
        left.style.display='flex'; left.style.alignItems='center'; left.style.gap='12px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox'; checkbox.checked = !!f.selected; checkbox.style.width='18px'; checkbox.style.height='18px';
        checkbox.onchange = () => { f.selected = checkbox.checked; };

        const thumb = document.createElement('img');
        thumb.className = 'thumb';
        thumb.src = f.editedDataUrl || f.previewUrl;

        left.appendChild(checkbox);
        left.appendChild(thumb);

        const meta = document.createElement('div');
        meta.className = 'file-meta';
        meta.innerHTML = `<div class="file-row"><div style="flex:1"><div class="file-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</div><div class="small">${t.origSize}: ${f.naturalWidth}×${f.naturalHeight}</div></div><div style="display:flex;flex-direction:column;gap:6px"><div style="display:flex;gap:6px"><button class='btn ghost' data-idx='${idx}'>${t.editBtn}</button><button class='btn ghost' data-up='${idx}'>↑</button><button class='btn ghost' data-down='${idx}'>↓</button></div><button class='btn danger' data-del='${idx}'>${t.deleteBtn}</button></div></div>`;

        div.appendChild(left);
        div.appendChild(meta);
        fileListEl.appendChild(div);
      });

      fileListEl.querySelectorAll('button[data-idx]').forEach(btn=>{ btn.onclick = (ev) => openEditor(parseInt(btn.dataset.idx)); });
      fileListEl.querySelectorAll('button[data-up]').forEach(btn=>{ btn.onclick = () => { const i = parseInt(btn.dataset.up); if (i>0) { [files[i-1],files[i]] = [files[i],files[i-1]]; renderList(); } }; });
      fileListEl.querySelectorAll('button[data-down]').forEach(btn=>{ btn.onclick = () => { const i = parseInt(btn.dataset.down); if (i < files.length-1){ [files[i+1],files[i]] = [files[i],files[i+1]]; renderList(); } }; });
      fileListEl.querySelectorAll('button[data-del]').forEach(btn=>{ btn.onclick = () => { const i = parseInt(btn.dataset.del); files.splice(i,1); renderList(); }; });
    }

    let isDragging = false;
    let dragStart = null;
    let dragRect = null;
    let displayScale = 1;
    let currentImg = null;
    let displayToOriginal = 1;

    // --- helper: преобразование координат между отображением и оригиналом с учётом поворотов и отражений ---
    function mapDisplayRectToOriginal(rect, s){
      // rect в координатах canvas (editorCanvas.width/height)
      const w = editorCanvas.width, h = editorCanvas.height;
      const cx = w/2, cy = h/2;
      const angle = (((s.rotation % 360) + 360) % 360) * Math.PI/180;
      const scaleX = s.flipH ? -1 : 1;
      const scaleY = s.flipV ? -1 : 1;
      const invScaleX = 1/scaleX; // = scaleX (±1)
      const invScaleY = 1/scaleY;
      const corners = [
        {x: rect.x, y: rect.y},
        {x: rect.x + rect.w, y: rect.y},
        {x: rect.x, y: rect.y + rect.h},
        {x: rect.x + rect.w, y: rect.y + rect.h}
      ];
      const mapped = corners.map(pt => {
        const dx = pt.x - cx, dy = pt.y - cy;
        const vx = dx * invScaleX, vy = dy * invScaleY;
        const cosA = Math.cos(-angle), sinA = Math.sin(-angle);
        const tx = cosA * vx - sinA * vy;
        const ty = sinA * vx + cosA * vy;
        const tmpX = tx + cx;
        const tmpY = ty + cy;
        const origX = Math.round(tmpX * displayToOriginal);
        const origY = Math.round(tmpY * displayToOriginal);
        return {x: origX, y: origY};
      });
      const xs = mapped.map(p=>p.x), ys = mapped.map(p=>p.y);
      const minX = Math.max(0, Math.min(...xs));
      const minY = Math.max(0, Math.min(...ys));
      const maxX = Math.max(...xs);
      const maxY = Math.max(...ys);
      return { x: minX, y: minY, w: Math.max(1, maxX - minX), h: Math.max(1, maxY - minY) };
    }

    function mapOriginalCropToDisplayRect(crop, s){
      // crop в координатах оригинального изображения -> возвращаем rect в координатах canvas
      const w = editorCanvas.width, h = editorCanvas.height;
      const cx = w/2, cy = h/2;
      const angle = (((s.rotation % 360) + 360) % 360) * Math.PI/180;
      const scaleX = s.flipH ? -1 : 1;
      const scaleY = s.flipV ? -1 : 1;
      const cosA = Math.cos(angle), sinA = Math.sin(angle);
      const corners = [
        {x: crop.x, y: crop.y},
        {x: crop.x + crop.w, y: crop.y},
        {x: crop.x, y: crop.y + crop.h},
        {x: crop.x + crop.w, y: crop.y + crop.h}
      ].map(pt => {
        // tmp (до поворота) — это scaled оригинал
        const tmpX = pt.x * displayScale;
        const tmpY = pt.y * displayScale;
        const vx = tmpX - cx, vy = tmpY - cy;
        const px = scaleX * (cosA * vx - sinA * vy);
        const py = scaleY * (sinA * vx + cosA * vy);
        return { x: px + cx, y: py + cy };
      });
      const xs = corners.map(p=>p.x), ys = corners.map(p=>p.y);
      const minX = Math.min(...xs), minY = Math.min(...ys), maxX = Math.max(...xs), maxY = Math.max(...ys);
      return { x: Math.round(minX), y: Math.round(minY), w: Math.round(Math.max(1, maxX - minX)), h: Math.round(Math.max(1, maxY - minY)) };
    }
    // --- /helper ---

    async function openEditor(idx){
      if (idx <0 || idx >= files.length) return;
      editingIndex = idx;
      const f = files[idx];
      const t = TRANSLATIONS[langSelect.value];
      editorTitle.textContent = `${t.editorTitle} — ${f.name}`;
      editorInfo.textContent = '';
      currentImg = new Image();
      currentImg.src = f.originalDataUrl;
      await new Promise(r => currentImg.onload = r);
      edContrast.value = f.settings.contrast ?? 1.2;
      edContrastVal.textContent = Number(edContrast.value).toFixed(2);
      edBW.checked = !!f.settings.bw;
      updateTransformInfo();
      const maxDisplayW = Math.min(900, window.innerWidth - 380);
      const maxDisplayH = Math.min(600, window.innerHeight * 0.7);
      const scale = Math.min(1, maxDisplayW / currentImg.naturalWidth, maxDisplayH / currentImg.naturalHeight);
      displayScale = scale;
      displayToOriginal = 1/scale;
      const w = Math.round(currentImg.naturalWidth * scale);
      const h = Math.round(currentImg.naturalHeight * scale);
      editorCanvas.width = w; editorCanvas.height = h;
      editorCanvas.style.width = w + 'px'; editorCanvas.style.height = h + 'px';
      if (f.settings.crop){
        const c = f.settings.crop;
        // корректно отображаем сохранённую обрезку с учётом поворота/флипов
        dragRect = mapOriginalCropToDisplayRect(c, f.settings);
      } else {
        dragRect = null;
      }
      drawEditorCanvas();
      attachCanvasEvents();
      origSizeEl.textContent = `${currentImg.naturalWidth}×${currentImg.naturalHeight}`;
      editorModal.style.display = 'flex';
    }

    function updateTransformInfo(){ 
      if (editingIndex < 0) return; 
      const s = files[editingIndex].settings; 
      const cropInfo = s.crop ? `C:${s.crop.w}x${s.crop.h}` : '';
      curTransformEl.textContent = `R${s.rotation}° ${s.flipH?'H':''}${s.flipV?'V':''} ${s.bw?'BW':''} K:${s.contrast.toFixed(1)} ${cropInfo}`.trim(); 
    }

    function drawEditorCanvas(){
      if (!currentImg) return;
      const ctx = editorCanvas.getContext('2d');
      const f = files[editingIndex];
      const s = f.settings;
      ctx.clearRect(0,0,editorCanvas.width,editorCanvas.height);
      const tmp = document.createElement('canvas');
      tmp.width = editorCanvas.width; tmp.height = editorCanvas.height;
      const tctx = tmp.getContext('2d');
      // рисуем оригинал, масштабируя под tmp (до поворота)
      tctx.drawImage(currentImg, 0, 0, currentImg.naturalWidth, currentImg.naturalHeight, 0, 0, tmp.width, tmp.height);
      try {
        const imgData = tctx.getImageData(0,0,tmp.width,tmp.height);
        const data = imgData.data;
        const contrast = Number(s.contrast) || 1;
        const bw = !!s.bw;
        for (let i=0;i<data.length;i+=4){
          let r = data[i], g = data[i+1], b = data[i+2];
          let lum = 0.299*r + 0.587*g + 0.114*b;
          lum = ((lum - 128) * contrast) + 128;
          if (bw){
            const v = Math.max(0, Math.min(255, lum));
            data[i]=data[i+1]=data[i+2]=v;
          } else {
            data[i] = clamp(((r-128)*contrast)+128);
            data[i+1] = clamp(((g-128)*contrast)+128);
            data[i+2] = clamp(((b-128)*contrast)+128);
          }
        }
        tctx.putImageData(imgData,0,0);
      } catch (err){}
      ctx.save();
      const w = editorCanvas.width; const h = editorCanvas.height;
      ctx.translate(w/2, h/2);
      const angle = (s.rotation % 360) * Math.PI/180;
      ctx.rotate(angle);
      const scaleX = s.flipH ? -1 : 1;
      const scaleY = s.flipV ? -1 : 1;
      ctx.scale(scaleX, scaleY);
      ctx.drawImage(tmp, -w/2, -h/2, w, h);
      ctx.restore();
      if (dragRect){
        const r = dragRect;
        ctx.save();
        ctx.strokeStyle = '#ffcc00'; ctx.lineWidth = 2; ctx.setLineDash([6,4]);
        ctx.strokeRect(r.x+0.5, r.y+0.5, r.w, r.h);
        ctx.fillStyle = 'rgba(255,204,0,0.08)'; ctx.fillRect(r.x, r.y, r.w, r.h);
        ctx.restore();
      }
    }

    function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }

    function attachCanvasEvents(){
      editorCanvas.onmousedown = editorCanvas.onmousemove = editorCanvas.onmouseup = null;
      editorCanvas.ontouchstart = editorCanvas.ontouchmove = editorCanvas.ontouchend = null;

      editorCanvas.onmousedown = (e) => {
        isDragging = true;
        const rect = editorCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        dragStart = {x,y};
        dragRect = {x,y,w:0,h:0};
        drawEditorCanvas();
      };
      editorCanvas.onmousemove = (e) => {
        if (!isDragging) return;
        const rect = editorCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        const x0 = dragStart.x, y0 = dragStart.y;
        dragRect = { x: Math.min(x0,x), y: Math.min(y0,y), w: Math.abs(x-x0), h: Math.abs(y-y0) };
        drawEditorCanvas();
      };
      editorCanvas.onmouseup = (e) => { isDragging = false; dragStart = null; drawEditorCanvas(); };

      editorCanvas.ontouchstart = (ev) => { ev.preventDefault(); const t = ev.touches[0]; const rect = editorCanvas.getBoundingClientRect(); const x = (t.clientX - rect.left); const y = (t.clientY - rect.top); isDragging = true; dragStart = {x,y}; dragRect = {x,y,w:0,h:0}; drawEditorCanvas(); };
      editorCanvas.ontouchmove = (ev) => { ev.preventDefault(); if (!isDragging) return; const t = ev.touches[0]; const rect = editorCanvas.getBoundingClientRect(); const x = (t.clientX - rect.left); const y = (t.clientY - rect.top); const x0 = dragStart.x, y0 = dragStart.y; dragRect = { x: Math.min(x0,x), y: Math.min(y0,y), w: Math.abs(x-x0), h: Math.abs(y-y0) }; drawEditorCanvas(); };
      editorCanvas.ontouchend = (ev) => { isDragging = false; dragStart = null; drawEditorCanvas(); };
    }

    edContrast.addEventListener('input', ()=>{ edContrastVal.textContent = Number(edContrast.value).toFixed(2); if (editingIndex>=0){ files[editingIndex].settings.contrast = Number(edContrast.value); updateTransformInfo(); drawEditorCanvas(); } });
    edBW.addEventListener('change', ()=>{ if (editingIndex>=0){ files[editingIndex].settings.bw = edBW.checked; updateTransformInfo(); drawEditorCanvas(); } });
    rotLeft.addEventListener('click', ()=>{ rotateEditor(-90); });
    rotRight.addEventListener('click', ()=>{ rotateEditor(90); });
    flipHBtn.addEventListener('click', ()=>{ toggleFlip('H'); });
    flipVBtn.addEventListener('click', ()=>{ toggleFlip('V'); });

    // Универсальная функция: устанавливает обрезку из текущего dragRect с учётом трансформаций.
    function setCropFromRect(silent){
      if (editingIndex<0) return false;
      const t = TRANSLATIONS[langSelect.value];
      if (!dragRect || dragRect.w < 5 || dragRect.h < 5) {
        if (!silent) alert(t.selectArea);
        return false;
      }
      const s = files[editingIndex].settings;
      const origCrop = mapDisplayRectToOriginal(dragRect, s);
      files[editingIndex].settings.crop = origCrop;
      updateTransformInfo();
      drawEditorCanvas();
      if (!silent) alert(t.cropSet);
      return true;
    }

    function applyCropFromRect(){
      setCropFromRect(false);
    }

    applyCropBtn.addEventListener('click', ()=>{ applyCropFromRect(); });
    resetBtn.addEventListener('click', ()=>{ resetEditor(); });
    closeEditorBtn.addEventListener('click', ()=>{ editorModal.style.display='none'; editingIndex=-1; currentImg=null; });
    applyBtn.addEventListener('click', async ()=>{
      // если есть выделение (dragRect), но пользователь не нажал "Применить обрезку", — применяем автоматически (без alert).
      if (editingIndex >= 0 && dragRect && (!files[editingIndex].settings.crop || files[editingIndex].settings.crop.w === 0 || files[editingIndex].settings.crop.h === 0)){
        setCropFromRect(true);
      }
      await saveEdited();
      editorModal.style.display='none';
      editingIndex=-1; currentImg=null;
      renderList();
    });
    applyAndClose.addEventListener('click', async ()=>{
      if (editingIndex >= 0 && dragRect && (!files[editingIndex].settings.crop || files[editingIndex].settings.crop.w === 0 || files[editingIndex].settings.crop.h === 0)){
        setCropFromRect(true);
      }
      await saveEdited();
      editorModal.style.display='none';
      editingIndex=-1; currentImg=null;
      renderList();
    });
    toPrev.addEventListener('click', ()=>{ if (editingIndex>0) { openEditor(editingIndex-1); }});
    toNext.addEventListener('click', ()=>{ if (editingIndex < files.length-1) { openEditor(editingIndex+1); }});

    function rotateEditor(delta){ if (editingIndex<0) return; const s = files[editingIndex].settings; s.rotation = ( (s.rotation + delta) % 360 + 360 ) % 360; updateTransformInfo(); drawEditorCanvas(); }
    function toggleFlip(dir){ if (editingIndex<0) return; const s = files[editingIndex].settings; if (dir==='H') s.flipH = !s.flipH; if (dir==='V') s.flipV = !s.flipV; updateTransformInfo(); drawEditorCanvas(); }

    async function saveEdited(){ if (editingIndex<0) return; const f = files[editingIndex]; const dataUrl = await processImageToDataUrl(f); f.editedDataUrl = dataUrl; renderList(); }

    downloadBtn.addEventListener('click', async ()=>{
      const t = TRANSLATIONS[langSelect.value];
      if (!files.length) return alert(t.noFiles);
      downloadBtn.textContent = t.generating; downloadBtn.disabled = true;
      for (let i=0;i<files.length;i++){ if (!files[i].editedDataUrl) { files[i].editedDataUrl = await processImageToDataUrl(files[i]); } }
      try {
        const { jsPDF } = window.jspdf;
        const firstImg = await loadImage(files[0].editedDataUrl);
        const pdf = new jsPDF({ unit: 'px', format: [firstImg.width, firstImg.height] });
        pdf.addImage(files[0].editedDataUrl, 'JPEG', 0, 0, firstImg.width, firstImg.height);
        for (let i=1;i<files.length;i++){ const im = await loadImage(files[i].editedDataUrl); pdf.addPage([im.width, im.height]); pdf.addImage(files[i].editedDataUrl, 'JPEG', 0, 0, im.width, im.height); }
        const outName = (filenameInput.value.trim() || 'documents') + '.pdf'; pdf.save(outName);
      } catch (err){ console.error(err); alert('PDF yaratishda xatolik: ' + (err?.message || err)); }
      downloadBtn.textContent = t.download; downloadBtn.disabled = false;
    });

    mergeBtn.addEventListener('click', async ()=>{
      const t = TRANSLATIONS[langSelect.value];
      const sel = files.filter(f=>f.selected);
      if (sel.length !== 2) return alert(t.selectTwo);
      mergeBtn.textContent = t.merging; mergeBtn.disabled = true;
      try{
        const d1 = await loadImage(sel[0].originalDataUrl); const d2 = await loadImage(sel[1].originalDataUrl);
        const targetW = Math.max(d1.width, d2.width);
        const scale1 = targetW / d1.width; const scale2 = targetW / d2.width;
        const h1 = Math.round(d1.height * scale1); const h2 = Math.round(d2.height * scale2);
        const canvas = document.createElement('canvas'); canvas.width = targetW; canvas.height = h1 + h2;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(d1.img, 0, 0, d1.width, d1.height, 0, 0, targetW, h1);
        ctx.drawImage(d2.img, 0, 0, d2.width, d2.height, 0, h1, targetW, h2);
        const mergedDataUrl = canvas.toDataURL('image/jpeg',0.95);
        const id = uid();
        files.push({ id, name: `merged_${sel[0].name.replace(/\s+/g,'_')}_${sel[1].name.replace(/\s+/g,'_')}.jpg`, file: null, previewUrl: mergedDataUrl, originalDataUrl: mergedDataUrl, naturalWidth: canvas.width, naturalHeight: canvas.height, settings: { rotation:0, flipH:false, flipV:false, contrast:1.2, bw:false, crop:null }, editedDataUrl: mergedDataUrl, selected:false });
        renderList();
        alert(t.merged);
      } catch(e){ console.error(e); alert('Xatolik: '+(e?.message||e)); }
      mergeBtn.textContent = t.merge; mergeBtn.disabled = false;
    });

    function loadImage(dataUrl){
      return new Promise(res=>{ const img = new Image(); img.onload = () => res({ img, width: img.naturalWidth, height: img.naturalHeight }); img.src = dataUrl; });
    }

    async function processImageToDataUrl(fileObj){
      const srcImg = await new Promise(res=>{ const i=new Image(); i.onload=()=>res(i); i.src=fileObj.originalDataUrl; });
      let s = fileObj.settings;
      
      // Применяем обрезку к исходному изображению (учитываем crop, сохранённый в оригинальных координатах)
      let sx = 0, sy = 0, sw = srcImg.naturalWidth, sh = srcImg.naturalHeight;
      if (s.crop && s.crop.w > 0 && s.crop.h > 0){
        sx = Math.max(0, Math.min(s.crop.x, srcImg.naturalWidth - 1));
        sy = Math.max(0, Math.min(s.crop.y, srcImg.naturalHeight - 1));
        sw = Math.max(1, Math.min(s.crop.w, srcImg.naturalWidth - sx));
        sh = Math.max(1, Math.min(s.crop.h, srcImg.naturalHeight - sy));
      }
      
      // Создаем временный canvas с обрезанным изображением
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = sw;
      tempCanvas.height = sh;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(srcImg, sx, sy, sw, sh, 0, 0, sw, sh);
      
      // Теперь работаем с обрезанным изображением
      let dstW = sw, dstH = sh;
      const rot = ((s.rotation % 360) + 360) % 360;
      if (rot === 90 || rot === 270) { 
        dstW = sh; 
        dstH = sw; 
      }
      
      const MAX_DIM = 2500;
      let scale = Math.min(1, MAX_DIM / Math.max(dstW, dstH));
      const canvasW = Math.max(1, Math.round(dstW * scale));
      const canvasH = Math.max(1, Math.round(dstH * scale));
      
      // Применяем трансформации
      const destCanvas = document.createElement('canvas');
      destCanvas.width = canvasW;
      destCanvas.height = canvasH;
      const dctx = destCanvas.getContext('2d');
      
      dctx.save();
      dctx.translate(destCanvas.width/2, destCanvas.height/2);
      const angle = rot * Math.PI/180;
      dctx.rotate(angle);
      const scaleX = s.flipH ? -1 : 1;
      const scaleY = s.flipV ? -1 : 1;
      dctx.scale(scaleX, scaleY);
      
      // Рисуем обрезанное изображение с масштабированием
      const drawW = Math.round(sw * scale);
      const drawH = Math.round(sh * scale);
      dctx.drawImage(tempCanvas, -drawW/2, -drawH/2, drawW, drawH);
      dctx.restore();
      
      // Применяем фильтры
      try {
        const imgData = dctx.getImageData(0, 0, destCanvas.width, destCanvas.height);
        const data = imgData.data;
        const contrast = Number(s.contrast) || 1;
        const bw = !!s.bw;
        
        for (let i = 0; i < data.length; i += 4){
          let r = data[i], g = data[i+1], b = data[i+2];
          
          if (bw){
            let lum = 0.299*r + 0.587*g + 0.114*b;
            lum = ((lum - 128) * contrast) + 128;
            const v = clamp(lum);
            data[i] = data[i+1] = data[i+2] = v;
          } else {
            data[i] = clamp(((r-128)*contrast)+128);
            data[i+1] = clamp(((g-128)*contrast)+128);
            data[i+2] = clamp(((b-128)*contrast)+128);
          }
        }
        dctx.putImageData(imgData, 0, 0);
      } catch (err){ 
        console.warn('ImageData manipulation failed:', err);
      }
      
      const dataUrl = destCanvas.toDataURL('image/jpeg', 0.95);
      return dataUrl;
    }

    function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

    window.bobotog_get_files = () => files;
  })();
  </script>
</body>
</html>